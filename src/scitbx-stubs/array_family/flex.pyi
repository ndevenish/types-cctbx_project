import builtins
from typing import Any, Generic, Optional, Tuple, TypeVar, overload, type_check_only

# We inject methods here, let's ignore that for typing
# from .scitbx_array_family_flex_ext import *

T = TypeVar("T")
VT = TypeVar("VT")

@type_check_only
class FlexPlain(Generic[VT]):
    def accessor(self, *args, **kwargs) -> Any: ...
    def all(self, *args, **kwargs) -> Any: ...
    def append(self, *args, **kwargs) -> Any: ...
    def as_1d(self, *args, **kwargs) -> Any: ...
    def assign(self, *args, **kwargs) -> Any: ...
    def back(self, *args, **kwargs) -> Any: ...
    def capacity(self, *args, **kwargs) -> Any: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def concatenate(self: T, other: T) -> T: ...
    def deep_copy(self, *args, **kwargs) -> Any: ...
    def element_size(self, *args, **kwargs) -> Any: ...
    def extend(self, *args, **kwargs) -> Any: ...
    def fill(self, *args, **kwargs) -> Any: ...
    def focus_size_1d(self, *args, **kwargs) -> Any: ...
    def focus(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def id(self, *args, **kwargs) -> Any: ...
    def insert(self, *args, **kwargs) -> Any: ...
    def is_0_based(self, *args, **kwargs) -> Any: ...
    def is_padded(self, *args, **kwargs) -> Any: ...
    def is_trivial_1d(self, *args, **kwargs) -> Any: ...
    def last(self, *args, **kwargs) -> Any: ...
    def nd(self, *args, **kwargs) -> Any: ...
    def origin(self, *args, **kwargs) -> Any: ...
    def pop_back(self, *args, **kwargs) -> Any: ...
    def reserve(self, *args, **kwargs) -> Any: ...
    def reshape(self, *args, **kwargs) -> Any: ...
    def resize(self, *args, **kwargs) -> Any: ...
    def reversed(self, *args, **kwargs) -> Any: ...
    def shallow_copy(self, *args, **kwargs) -> Any: ...
    def shift_origin(self, *args, **kwargs) -> Any: ...
    def size(self, *args, **kwargs) -> Any: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __getitem_fgdit__(self, *args, **kwargs) -> Any: ...
    def __len__(self) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...
    def __sizeof__(self) -> Any: ...

@type_check_only
class FlexNumericCommon(FlexPlain[VT]):
    def count(self, *args, **kwargs) -> Any: ...
    def __add__(self, other) -> Any: ...
    def __div__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __iadd__(self, other) -> Any: ...
    def __idiv__(self, *args, **kwargs) -> Any: ...
    def __imul__(self, other) -> Any: ...
    def __isub__(self, other) -> Any: ...
    def __itruediv__(self, other) -> Any: ...
    def __mul__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __neg__(self) -> Any: ...
    def __radd__(self, other) -> Any: ...
    def __rdiv__(self, *args, **kwargs) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    def __sub__(self, other) -> Any: ...
    def __truediv__(self, other) -> Any: ...
    def all_eq(self, *args, **kwargs) -> Any: ...
    def all_ne(self, *args, **kwargs) -> Any: ...

@type_check_only
class FlexNumericNoPow(FlexNumericCommon[VT]):
    def as_double(self, *args, **kwargs) -> Any: ...
    def all_ge(self, *args, **kwargs) -> Any: ...
    def all_gt(self, *args, **kwargs) -> Any: ...
    def all_le(self, *args, **kwargs) -> Any: ...
    def all_lt(self, *args, **kwargs) -> Any: ...
    def norm_inf(self, *args, **kwargs) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...

@type_check_only
class FlexNumeric(FlexNumericCommon[VT]):
    def norm(self, *args, **kwargs) -> Any: ...
    def __pow__(self, other) -> Any: ...
    def __abs__(self) -> Any: ...

@type_check_only
class FlexInteger(FlexNumericNoPow[VT]):
    def __mod__(self, other) -> Any: ...
    def __imod__(self, other) -> Any: ...
    def __rmod__(self, other) -> Any: ...

@type_check_only
class FlexSignedInteger(FlexInteger[VT]):
    pass

@type_check_only
class FlexOrdered(FlexPlain[VT]):
    def __eq__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def all_eq(self, *args, **kwargs) -> Any: ...
    def all_ne(self, *args, **kwargs) -> Any: ...

class bool(FlexPlain[builtins.bool]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_int(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def exclusive_or(self, *args, **kwargs) -> Any: ...
    def filter_indices(self, *args, **kwargs) -> Any: ...
    def is_super_set(self, *args, **kwargs) -> Any: ...
    def iselection(self, *args, **kwargs) -> Any: ...
    def matrix_copy_block(self, *args, **kwargs) -> Any: ...
    def matrix_paste_block_in_place(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __and__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __iand__(self, other) -> Any: ...
    def __invert__(self) -> Any: ...
    def __ior__(self, other) -> Any: ...
    def __or__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class complex_double(FlexNumericCommon[complex]):
    def __init__(self, *args, **kwargs) -> None: ...
    def all_approx_equal(self, *args, **kwargs) -> Any: ...
    def all_approx_equal_relatively(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def matrix_copy_block(self, *args, **kwargs) -> Any: ...
    def matrix_multiply(self, *args, **kwargs) -> Any: ...
    def matrix_packed_u_as_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_packed_u_diagonal(self, *args, **kwargs) -> Any: ...
    def matrix_paste_block_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_transpose(self, *args, **kwargs) -> Any: ...
    def part_names(self, *args, **kwargs) -> Any: ...
    def parts(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class cost_of_m_handle_in_af_shared:
    def __init__(self, *args, **kwargs) -> None: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...
    @property
    def result(self) -> Any: ...

class double(FlexNumeric[builtins.float]):
    def __getstate__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def add_selected(self, *args, **kwargs) -> Any: ...
    def all_approx_equal_relatively(self, *args, **kwargs) -> Any: ...
    def all_approx_equal(self, *args, **kwargs) -> Any: ...
    def angle(self, *args, **kwargs) -> Any: ...
    def as_float(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def as_string(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def cos_angle(self, *args, **kwargs) -> Any: ...
    def dot(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def iround(self) -> int: ...
    def is_square_matrix(self, *args, **kwargs) -> Any: ...
    def mathematica_form(self, *args, **kwargs) -> Any: ...
    def matrix_back_substitution_given_transpose(self, *args, **kwargs) -> Any: ...
    def matrix_back_substitution(self, *args, **kwargs) -> Any: ...
    def matrix_copy_block(
        self: T,
        i_row: builtins.int,
        i_column: builtins.int,
        i_rows: builtins.int,
        i_columns: builtins.int,
    ) -> T: ...
    def matrix_copy_column(self, *args, **kwargs) -> Any: ...
    def matrix_copy_lower_to_upper_triangle_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_copy_lower_triangle(self, *args, **kwargs) -> Any: ...
    def matrix_copy_upper_to_lower_triangle_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_copy_upper_triangle(self, *args, **kwargs) -> Any: ...
    def matrix_determinant_via_lu(self, *args, **kwargs) -> Any: ...
    def matrix_diagonal_add_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_diagonal_product(self, *args, **kwargs) -> Any: ...
    def matrix_diagonal_set_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_diagonal_sum(self, *args, **kwargs) -> Any: ...
    def matrix_diagonal(self, *args, **kwargs) -> Any: ...
    def matrix_forward_substitution_given_transpose(self, *args, **kwargs) -> Any: ...
    def matrix_forward_substitution(self, *args, **kwargs) -> Any: ...
    def matrix_inversion_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_is_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_lower_bidiagonal(self, *args, **kwargs) -> Any: ...
    def matrix_lower_triangle_as_packed_l(self, *args, **kwargs) -> Any: ...
    def matrix_lu_back_substitution(self, *args, **kwargs) -> Any: ...
    def matrix_lu_decomposition_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_multiply_packed_u_multiply_lhs_transpose(
        self, *args, **kwargs
    ) -> Any: ...
    def matrix_multiply_packed_u(self, *args, **kwargs) -> Any: ...
    def matrix_multiply_transpose(self, *args, **kwargs) -> Any: ...
    def matrix_multiply(self, *args, **kwargs) -> Any: ...
    def matrix_norm_1(self, *args, **kwargs) -> Any: ...
    def matrix_norm_frobenius(self, *args, **kwargs) -> Any: ...
    def matrix_norm_inf(self, *args, **kwargs) -> Any: ...
    def matrix_outer_product(self, *args, **kwargs) -> Any: ...
    def matrix_packed_l_as_lower_triangle(self, *args, **kwargs) -> Any: ...
    def matrix_packed_l_as_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_packed_u_as_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_packed_u_as_upper_triangle(self, *args, **kwargs) -> Any: ...
    def matrix_packed_u_diagonal_add_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_packed_u_diagonal(self, *args, **kwargs) -> Any: ...
    def matrix_packed_u_swap_rows_and_columns_in_place(
        self, *args, **kwargs
    ) -> Any: ...
    def matrix_paste_block_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_paste_column_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_rot90(self, *args, **kwargs) -> Any: ...
    def matrix_swap_columns_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_swap_rows_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_symmetric_as_packed_l(self, *args, **kwargs) -> Any: ...
    def matrix_symmetric_as_packed_u(self, *args, **kwargs) -> Any: ...
    def matrix_symmetric_upper_triangle_quadratic_form(
        self, *args, **kwargs
    ) -> Any: ...
    def matrix_symmetric_upper_triangle_swap_rows_and_columns_in_place(
        self, *args, **kwargs
    ) -> Any: ...
    def matrix_trace(self, *args, **kwargs) -> Any: ...
    def matrix_transpose_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_transpose_multiply_as_packed_u(self, *args, **kwargs) -> Any: ...
    def matrix_transpose_multiply_diagonal_multiply_as_packed_u(
        self, *args, **kwargs
    ) -> Any: ...
    def matrix_transpose_multiply(self, *args, **kwargs) -> Any: ...
    def matrix_transpose(self, *args, **kwargs) -> Any: ...
    def matrix_upper_bidiagonal(self, *args, **kwargs) -> Any: ...
    def matrix_upper_triangle_as_packed_u(self, *args, **kwargs) -> Any: ...
    def norm_1(self, *args, **kwargs) -> Any: ...
    def round(self, n_digits: builtins.int) -> double: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def slice_to_byte_str(self, *args, **kwargs) -> Any: ...
    # Injected
    def matrix_inversion(self): ...
    def as_scitbx_matrix(self): ...

class flex_argument_passing:
    def __init__(self, *args, **kwargs) -> None: ...
    def easy_versa_flex_grid_as_reference(self, *args, **kwargs) -> Any: ...
    def shared_as_reference_fails(self, *args, **kwargs) -> Any: ...
    def shared_as_value_fails(self, *args, **kwargs) -> Any: ...
    def versa_flex_grid_as_reference_succeeds(self, *args, **kwargs) -> Any: ...
    def versa_flex_grid_as_value_fails(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...

class float(FlexNumeric[builtins.float]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class grid:
    def __init__(self, *args, **kwargs) -> None: ...
    def all(self, *args, **kwargs) -> Any: ...
    def focus(self, *args, **kwargs) -> Any: ...
    def focus_size_1d(self, *args, **kwargs) -> Any: ...
    def is_0_based(self, *args, **kwargs) -> Any: ...
    def is_padded(self, *args, **kwargs) -> Any: ...
    def is_trivial_1d(self, *args, **kwargs) -> Any: ...
    def is_valid_index(self, *args, **kwargs) -> Any: ...
    def last(self, *args, **kwargs) -> Any: ...
    def nd(self, *args, **kwargs) -> Any: ...
    def origin(self, *args, **kwargs) -> Any: ...
    def set_focus(self, *args, **kwargs) -> Any: ...
    def shift_origin(self, *args, **kwargs) -> Any: ...
    def size_1d(self, *args, **kwargs) -> Any: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __getinitargs__(self) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __ne__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    # Injected
    def show_summary(self, f: Optional[Any] = ...): ...

class histogram:
    def __init__(self, *args, **kwargs) -> None: ...
    def data_max(self, *args, **kwargs) -> Any: ...
    def data_min(self, *args, **kwargs) -> Any: ...
    def get_cutoff(self, *args, **kwargs) -> Any: ...
    def get_i_slot(self, *args, **kwargs) -> Any: ...
    def n_out_of_slot_range(self, *args, **kwargs) -> Any: ...
    def slot_centers(self, *args, **kwargs) -> Any: ...
    def slot_width(self, *args, **kwargs) -> Any: ...
    def slots(self, *args, **kwargs) -> Any: ...
    def update(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...
    # Injected
    def __getinitargs__(self): ...
    def slot_infos(self) -> None: ...
    def show(
        self, f: Optional[Any] = ..., prefix: str = ..., format_cutoffs: str = ...
    ) -> None: ...
    def as_str(self, prefix: str = ..., format_cutoffs: str = ...): ...

class int(FlexSignedInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_bool(self, *args, **kwargs) -> Any: ...
    def as_long(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def as_rgb_scale_string(self, *args, **kwargs) -> Any: ...
    def as_size_t(self, *args, **kwargs) -> Any: ...
    def as_string(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def matrix_copy_block(self, *args, **kwargs) -> Any: ...
    def matrix_is_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_paste_block_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_rot90(self, *args, **kwargs) -> Any: ...
    def matrix_swap_columns_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_swap_rows_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_transpose_in_place(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def slice_to_byte_str(self, *args, **kwargs) -> Any: ...
    def __and__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __invert__(self) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __or__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __xor__(self, other) -> Any: ...

class int16(FlexSignedInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_bool(self, *args, **kwargs) -> Any: ...
    def as_long(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def as_rgb_scale_string(self, *args, **kwargs) -> Any: ...
    def as_size_t(self, *args, **kwargs) -> Any: ...
    def as_string(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def matrix_copy_block(self, *args, **kwargs) -> Any: ...
    def matrix_is_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_paste_block_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_rot90(self, *args, **kwargs) -> Any: ...
    def matrix_swap_columns_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_swap_rows_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_transpose_in_place(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def slice_to_byte_str(self, *args, **kwargs) -> Any: ...
    def __and__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __invert__(self) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __or__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __xor__(self, other) -> Any: ...

class int8(FlexSignedInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_bool(self, *args, **kwargs) -> Any: ...
    def as_long(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def as_rgb_scale_string(self, *args, **kwargs) -> Any: ...
    def as_size_t(self, *args, **kwargs) -> Any: ...
    def as_string(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def matrix_copy_block(self, *args, **kwargs) -> Any: ...
    def matrix_is_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_paste_block_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_rot90(self, *args, **kwargs) -> Any: ...
    def matrix_swap_columns_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_swap_rows_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_transpose_in_place(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def slice_to_byte_str(self, *args, **kwargs) -> Any: ...
    def __and__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __invert__(self) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __or__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __xor__(self, other) -> Any: ...

class linear_correlation:
    def __init__(
        self,
        x: double,
        y: double,
        epsilon: builtins.float = 1.0e-15,
        subtract_mean: builtins.bool = True,
    ) -> None: ...
    def coefficient(self) -> builtins.float: ...
    def denominator(self) -> builtins.float: ...
    def is_well_defined(self) -> builtins.bool: ...
    def mean_x(self) -> builtins.float: ...
    def mean_y(self) -> builtins.float: ...
    def n(self) -> builtins.int: ...
    def numerator(self) -> builtins.float: ...
    def sum_denominator_x(self) -> builtins.float: ...
    def sum_denominator_y(self) -> builtins.float: ...
    def __reduce__(self) -> Any: ...
    # Injected
    def show_summary(self, f: Optional[Any] = ..., prefix: str = ...) -> None: ...

class linear_regression(linear_regression_core):
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...

class linear_regression_core:
    def __init__(self, *args, **kwargs) -> None: ...
    def is_well_defined(self) -> Any: ...
    def slope(self) -> Any: ...
    def y_intercept(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    # Injected
    def show_summary(self, f: Optional[Any] = ..., prefix: str = ...) -> None: ...

class long(FlexSignedInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_bool(self, *args, **kwargs) -> Any: ...
    def as_long(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def as_rgb_scale_string(self, *args, **kwargs) -> Any: ...
    def as_size_t(self, *args, **kwargs) -> Any: ...
    def as_string(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def matrix_copy_block(self, *args, **kwargs) -> Any: ...
    def matrix_is_symmetric(self, *args, **kwargs) -> Any: ...
    def matrix_paste_block_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_rot90(self, *args, **kwargs) -> Any: ...
    def matrix_swap_columns_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_swap_rows_in_place(self, *args, **kwargs) -> Any: ...
    def matrix_transpose_in_place(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def slice_to_byte_str(self, *args, **kwargs) -> Any: ...
    def __and__(self, other) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __invert__(self) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __or__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...
    def __xor__(self, other) -> Any: ...

class mat3_double(
    FlexPlain[
        Tuple[
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
        ]
    ]
):
    def __init__(self, *args, **kwargs) -> None: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class mean_and_variance:
    def __init__(self, *args, **kwargs) -> None: ...
    def gsl_stats_wsd(self) -> Any: ...
    def gsl_stats_wvariance(self) -> Any: ...
    def have_weights(self) -> Any: ...
    def mean(self) -> Any: ...
    def standard_error_of_mean_calculated_from_sample_weights(self) -> Any: ...
    def sum_weights(self) -> Any: ...
    def sum_weights_delta_sq(self) -> Any: ...
    def sum_weights_sq(self) -> Any: ...
    def sum_weights_values(self) -> Any: ...
    def unweighted_sample_standard_deviation(self) -> Any: ...
    def unweighted_sample_variance(self) -> Any: ...
    def unweighted_standard_error_of_mean(self) -> Any: ...
    def __reduce__(self) -> Any: ...

class median_functor:
    def __init__(self, *args, **kwargs) -> None: ...
    def dispersion(self, *args, **kwargs) -> Any: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...

class median_statistics:
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    @property
    def median(self) -> Any: ...
    @property
    def median_absolute_deviation(self) -> Any: ...

class mersenne_twister:
    def __init__(self, *args, **kwargs) -> None: ...
    def getstate(self) -> Any: ...
    def random_bool(self, unsignedlong, double) -> Any: ...
    @overload
    def random_double(scitbx) -> Any: ...
    @overload
    def random_double(scitbx, unsignedlong) -> Any: ...
    @overload
    def random_double(scitbx, unsignedlong, double) -> Any: ...
    def random_double_point_on_sphere(self) -> Any: ...
    def random_double_r3_rotation_matrix(self) -> Any: ...
    def random_double_r3_rotation_matrix_arvo_1992(self) -> Any: ...
    def random_double_unit_quaternion(self) -> Any: ...
    def random_int_gaussian_distribution(self, *args, **kwargs) -> Any: ...
    def random_permutation(self, unsignedlong) -> Any: ...
    @overload
    def random_size_t(scitbx) -> Any: ...
    @overload
    def random_size_t(scitbx, unsignedlong) -> Any: ...
    def random_size_t_max(self) -> Any: ...
    def random_size_t_min(self) -> Any: ...
    def seed(self) -> Any: ...
    def setstate(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...
    # Injected
    def random_selection(self, population_size, sample_size): ...

class mersenne_twister_legacy_boost_1_63:
    def __init__(self, *args, **kwargs) -> None: ...
    def random_double_r3_rotation_matrix(self) -> Any: ...
    def random_double_unit_quaternion(self) -> Any: ...
    def __reduce__(self) -> Any: ...

class min_max_mean_double:
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    @property
    def max(self) -> Any: ...
    @property
    def mean(self) -> Any: ...
    @property
    def min(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    @property
    def sum(self) -> Any: ...
    # Injected
    def show(
        self,
        out: Optional[Any] = ...,
        prefix: str = ...,
        format: str = ...,
        show_n: bool = ...,
    ): ...
    def as_tuple(self): ...

class nested_loop:
    def __init__(self, *args, **kwargs) -> None: ...
    def begin(self, *args, **kwargs) -> Any: ...
    def end(self, *args, **kwargs) -> Any: ...
    def incr(self, *args, **kwargs) -> Any: ...
    def next(self, *args, **kwargs) -> Any: ...
    def over(self, *args, **kwargs) -> Any: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    @classmethod
    def __iter__(boost) -> Any: ...
    def __next__(self) -> Any: ...
    def __reduce__(self) -> Any: ...

class size_t(FlexInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_int(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def increment_and_track_up_from_zero(self, *args, **kwargs) -> Any: ...
    def intersection(self, *args, **kwargs) -> Any: ...
    def intersection_i_seqs(self, *args, **kwargs) -> Any: ...
    def inverse_permutation(self, *args, **kwargs) -> Any: ...
    def next_permutation(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class std_string(FlexOrdered[str]):
    def __init__(self, *args, **kwargs) -> None: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def i_seqs_by_value(self, *args, **kwargs) -> Any: ...
    def lower(self, *args, **kwargs) -> Any: ...
    def max_element_length(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def strip(self, *args, **kwargs) -> Any: ...
    def upper(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class sym_mat3_double(
    FlexPlain[
        Tuple[
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
            builtins.float,
        ]
    ]
):
    def __init__(self, *args, **kwargs) -> None: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def norms(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class tiny_size_t_2(FlexPlain[Tuple[builtins.float, builtins.float]]):
    def __init__(self, *args, **kwargs) -> None: ...
    def column(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...

class uint16(FlexInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_int(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def increment_and_track_up_from_zero(self, *args, **kwargs) -> Any: ...
    def intersection(self, *args, **kwargs) -> Any: ...
    def intersection_i_seqs(self, *args, **kwargs) -> Any: ...
    def inverse_permutation(self, *args, **kwargs) -> Any: ...
    def next_permutation(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class uint32(FlexInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_int(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def increment_and_track_up_from_zero(self, *args, **kwargs) -> Any: ...
    def intersection(self, *args, **kwargs) -> Any: ...
    def intersection_i_seqs(self, *args, **kwargs) -> Any: ...
    def inverse_permutation(self, *args, **kwargs) -> Any: ...
    def next_permutation(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class uint8(FlexInteger[builtins.int]):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_int(self, *args, **kwargs) -> Any: ...
    def as_numpy_array(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def copy_to_byte_str(self, *args, **kwargs) -> Any: ...
    def counts(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def increment_and_track_up_from_zero(self, *args, **kwargs) -> Any: ...
    def intersection(self, *args, **kwargs) -> Any: ...
    def intersection_i_seqs(self, *args, **kwargs) -> Any: ...
    def inverse_permutation(self, *args, **kwargs) -> Any: ...
    def next_permutation(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __ge__(self, other) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __le__(self, other) -> Any: ...
    def __lt__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class vec2_double(FlexPlain[Tuple[builtins.float, builtins.float]]):
    def __init__(boost, scitbx) -> None: ...
    def add_selected(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def distance_matrix(self, *args, **kwargs) -> Any: ...
    def dot(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def max(self, *args, **kwargs) -> Any: ...
    def max_distance(self, *args, **kwargs) -> Any: ...
    def mean(self, *args, **kwargs) -> Any: ...
    def mean_weighted(self, *args, **kwargs) -> Any: ...
    def min(self, *args, **kwargs) -> Any: ...
    def min_distance_between_any_pair(self, *args, **kwargs) -> Any: ...
    def min_distance_between_any_pair_with_id(self, *args, **kwargs) -> Any: ...
    def parts(self, *args, **kwargs) -> Any: ...
    def rms_difference(self, *args, **kwargs) -> Any: ...
    def rms_length(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def sum(self, *args, **kwargs) -> Any: ...
    def sum_sq(self, *args, **kwargs) -> Any: ...
    def transpose_multiply(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class vec3_double(FlexPlain[Tuple[builtins.float, builtins.float, builtins.float]]):
    def __init__(self, *args, **kwargs) -> None: ...
    def add_selected(self, *args, **kwargs) -> Any: ...
    def angle(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def cross(self, *args, **kwargs) -> Any: ...
    def dot(self, *args, **kwargs) -> Any: ...
    def each_normalize(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def iround(self, *args, **kwargs) -> Any: ...
    def max(self, *args, **kwargs) -> Any: ...
    def max_distance(self, *args, **kwargs) -> Any: ...
    def max_distance_between_any_pair_with_id(self, *args, **kwargs) -> Any: ...
    def mean(self, *args, **kwargs) -> Any: ...
    def mean_weighted(self, *args, **kwargs) -> Any: ...
    def min(self, *args, **kwargs) -> Any: ...
    def min_distance_between_any_pair(self, *args, **kwargs) -> Any: ...
    def min_distance_between_any_pair_with_id(self, *args, **kwargs) -> Any: ...
    def norms(self, *args, **kwargs) -> Any: ...
    def part_names(self, *args, **kwargs) -> Any: ...
    def parts(self, *args, **kwargs) -> Any: ...
    def rms_difference(self, *args, **kwargs) -> Any: ...
    def rms_length(self, *args, **kwargs) -> Any: ...
    def rotate_around_origin(self, *args, **kwargs) -> Any: ...
    def round(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def sum(self, *args, **kwargs) -> Any: ...
    def sum_sq(self, *args, **kwargs) -> Any: ...
    def transpose_multiply(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class vec3_int(FlexPlain[Tuple[builtins.int, builtins.int, builtins.int]]):
    def __init__(self, *args, **kwargs) -> None: ...
    def add_selected(self, *args, **kwargs) -> Any: ...
    def as_int(self, *args, **kwargs) -> Any: ...
    def as_vec3_double(self, *args, **kwargs) -> Any: ...
    def copy_selected(self, *args, **kwargs) -> Any: ...
    def front(self, *args, **kwargs) -> Any: ...
    def select(self, *args, **kwargs) -> Any: ...
    def set_selected(self, *args, **kwargs) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class weighted_histogram:
    def __init__(self, *args, **kwargs) -> None: ...
    def data_max(self, *args, **kwargs) -> Any: ...
    def data_min(self, *args, **kwargs) -> Any: ...
    def get_cutoff(self, *args, **kwargs) -> Any: ...
    def get_i_slot(self, *args, **kwargs) -> Any: ...
    def n_out_of_slot_range(self, *args, **kwargs) -> Any: ...
    def slot_centers(self, *args, **kwargs) -> Any: ...
    def slot_width(self, *args, **kwargs) -> Any: ...
    def slots(self, *args, **kwargs) -> Any: ...
    def update(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...
    # Injected
    def __getinitargs__(self): ...
    def slot_infos(self) -> None: ...
    def show(
        self, f: Optional[Any] = ..., prefix: str = ..., format_cutoffs: str = ...
    ) -> None: ...

def abs(*args, **kwargs) -> Any: ...
def acos(*args, **kwargs) -> Any: ...
def arg(*args, **kwargs) -> Any: ...
def asin(*args, **kwargs) -> Any: ...
def atan(*args, **kwargs) -> Any: ...
def atan2(*args, **kwargs) -> Any: ...
def ceil(*args, **kwargs) -> Any: ...
def conj(*args, **kwargs) -> Any: ...
def cos(*args, **kwargs) -> Any: ...
def cosh(*args, **kwargs) -> Any: ...
def double_from_byte_str(boost) -> Any: ...
def empty_container_sizes_double() -> Any: ...
def empty_container_sizes_int() -> Any: ...
def exercise_versa_packed_u_to_flex() -> Any: ...
def exp(*args, **kwargs) -> Any: ...
def extract_double_attributes(*args, **kwargs) -> Any: ...
def fabs(*args, **kwargs) -> Any: ...
def first_index(*args, **kwargs) -> Any: ...
def floor(*args, **kwargs) -> Any: ...
def fmod(*args, **kwargs) -> Any: ...
def fmod_positive(*args, **kwargs) -> Any: ...
def imag(*args, **kwargs) -> Any: ...
def int16_from_byte_str(boost) -> Any: ...
def int8_from_byte_str(boost) -> Any: ...
def int_from_byte_str(boost) -> Any: ...
def integer_offsets_vs_pointers(*args, **kwargs) -> Any: ...
def intersection(unsignedlong, boost) -> Any: ...
def last_index(*args, **kwargs) -> Any: ...
def linear_interpolation(*args, **kwargs) -> Any: ...
def log(*args, **kwargs) -> Any: ...
def log10(*args, **kwargs) -> Any: ...
def long_from_byte_str(boost) -> Any: ...
def max(*args, **kwargs) -> Any: ...
def max_absolute(*args, **kwargs) -> Any: ...
def max_index(*args, **kwargs) -> Any: ...
def mean(*args, **kwargs) -> Any: ...
def mean_sq(*args, **kwargs) -> Any: ...
def mean_sq_weighted(*args, **kwargs) -> Any: ...
def mean_weighted(*args, **kwargs) -> Any: ...
def min(*args, **kwargs) -> Any: ...
def min_index(*args, **kwargs) -> Any: ...
def order(*args, **kwargs) -> Any: ...
def polar(*args, **kwargs) -> Any: ...
def pow(*args, **kwargs) -> Any: ...
def pow2(*args, **kwargs) -> Any: ...
def product(*args, **kwargs) -> Any: ...
def real(*args, **kwargs) -> Any: ...
def reindexing_array(*args, **kwargs) -> Any: ...
def sin(*args, **kwargs) -> Any: ...
def sinh(*args, **kwargs) -> Any: ...
def size_t_from_byte_str(boost) -> Any: ...
def slice_indices(unsignedlong, boost) -> Any: ...
def sort_permutation(*args, **kwargs) -> Any: ...
def split_lines(boost) -> Any: ...
def sqrt(*args, **kwargs) -> Any: ...
def sum(flex_array, axis: Optional[Any] = ...): ...
def sum_sq(*args, **kwargs) -> Any: ...
def tan(*args, **kwargs) -> Any: ...
def tanh(*args, **kwargs) -> Any: ...
def tst_c_grid_flex_conversion(*args, **kwargs) -> Any: ...
def uint16_from_byte_str(boost) -> Any: ...
def uint32_from_byte_str(boost) -> Any: ...
def uint8_from_byte_str(boost) -> Any: ...
def union(unsignedlong, boost) -> Any: ...
def bool_md5(self): ...
def sorted(data, reverse: bool = ..., stable: bool = ...): ...
def as_scitbx_matrix(a): ...
def show(a) -> None: ...
def rows(a) -> None: ...
def upper_bidiagonal(d, f): ...
def lower_bidiagonal(d, f): ...
def export_to(target_module_name) -> None: ...
def to_list(array): ...
def min_default(values, default): ...
def max_default(values, default): ...
def mean_default(values, default): ...
def select(sequence, permutation: Optional[Any] = ..., flags: Optional[Any] = ...): ...
def condense_as_ranges(integer_array): ...

random_generator: Any
random_size_t: Any
random_double: Any
random_bool: Any
random_permutation: Any
random_selection: Any
random_double_point_on_sphere: Any
random_double_unit_quaternion: Any
random_double_r3_rotation_matrix: Any
random_double_r3_rotation_matrix_arvo_1992: Any
random_int_gaussian_distribution: Any
median: Any

class py_object:
    def __init__(
        self,
        accessor,
        value: Optional[Any] = ...,
        values: Optional[Any] = ...,
        value_factory: Optional[Any] = ...,
    ) -> None: ...
    def accessor(self): ...
    def data(self): ...

class histogram_slot_info:
    low_cutoff: Any
    high_cutoff: Any
    n: Any
    def __init__(self, low_cutoff, high_cutoff, n) -> None: ...
    def center(self): ...

def show_count_stats(
    counts,
    group_size: int = ...,
    label_0: str = ...,
    out: Optional[Any] = ...,
    prefix: str = ...,
) -> None: ...

class weighted_histogram_slot_info:
    low_cutoff: Any
    high_cutoff: Any
    n: Any
    def __init__(self, low_cutoff, high_cutoff, n) -> None: ...
    def center(self): ...

def permutation_generator(size) -> None: ...

class smart_selection:
    bool_element_size: Any
    size_t_element_size: Any
    def __init__(
        self,
        flags: Optional[Any] = ...,
        indices: Optional[Any] = ...,
        all_size: Optional[Any] = ...,
    ) -> None: ...
    all_size: Any
    selected_size: Any
    flags: Any
    indices: Any
    def __eq__(self, other): ...
    def format_summary(self): ...
    def show_summary(
        self, out: Optional[Any] = ..., prefix: str = ..., label: str = ...
    ) -> None: ...

show_sizes_int: Any
show_sizes_double: Any

def exercise_triple(
    flex_triple, flex_order: Optional[Any] = ..., as_double: bool = ...
) -> None: ...
def compare_derivatives(more_reliable, less_reliable, eps: float = ...) -> None: ...

int32: Any
int32_from_byte_str: Any
int32_range: Any
int64: Any
int64_from_byte_str: Any
int64_range: Any
uint64: Any
uint64_from_byte_str: Any
uint64_range: Any

def double_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> double: ...
def float_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> float: ...
def int16_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> int16: ...
def int_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> int: ...
def int8_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> int8: ...
def long_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> long: ...
def size_t_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> size_t: ...
def uint16_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> uint16: ...
def uint32_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> uint32: ...
def uint8_range(
    start: __builtins__.int, stop: __builtins__.int, step: __builtins__.int = 1
) -> uint8: ...
