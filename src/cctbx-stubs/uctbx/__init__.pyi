# Mostly autogenerated stubs, a mix of monkeytype and stubgen.
# Thus, highly WIP and not at all authoratative

from typing import Any, List, Optional, Tuple, Union, overload

from scitbx.matrix import rec

class unit_cell:
    # From subclass with same name
    def __init__(
        self,
        parameters: Optional[
            Union[
                List[float],
                Tuple[float, float, float, float, float, float],
                Tuple[int, int, int, int, int, int],
            ]
        ] = ...,
        metrical_matrix: None = ...,
        orthogonalization_matrix: Optional[rec] = ...,
    ) -> None: ...
    debye_waller_factor: Any
    def __format__(self, format_spec: str = ...): ...
    def box_frac_around_sites(
        self,
        sites_cart: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        buffer: Optional[Any] = ...,
    ): ...
    def buffer_shifts_frac(self, buffer): ...
    def change_of_basis_op_to_niggli_cell(
        self,
        relative_epsilon: Optional[Any] = ...,
        iteration_limit: Optional[Any] = ...,
    ): ...
    def complete_miller_set_with_lattice_symmetry(
        self, anomalous_flag, d_min, lattice_symmetry_max_delta: int = ...
    ): ...
    def debye_waller_factors(
        self,
        miller_index: Optional[Any] = ...,
        miller_indices: Optional[Any] = ...,
        u_iso: Optional[Any] = ...,
        b_iso: Optional[Any] = ...,
        u_cart: Optional[Any] = ...,
        b_cart: Optional[Any] = ...,
        u_cif: Optional[Any] = ...,
        u_star: Optional[Any] = ...,
        exp_arg_limit: int = ...,
        truncate_exp_arg: bool = ...,
    ): ...
    def distance_mod_1(self, site_frac_1, site_frac_2): ...
    def is_buerger_cell(self, relative_epsilon: Optional[Any] = ...): ...
    def is_conventional_hexagonal_basis(
        self,
        absolute_length_tolerance: float = ...,
        absolute_angle_tolerance: float = ...,
    ): ...
    def is_conventional_rhombohedral_basis(
        self,
        absolute_length_tolerance: float = ...,
        absolute_angle_tolerance: float = ...,
    ): ...
    def is_niggli_cell(self, relative_epsilon: Optional[Any] = ...): ...
    def lattice_symmetry_group(
        self,
        max_delta: int = ...,
        enforce_max_delta_for_generated_two_folds: bool = ...,
    ): ...
    def minimum_cell(
        self,
        iteration_limit: Optional[Any] = ...,
        multiplier_significant_change_test: Optional[Any] = ...,
        min_n_no_significant_change: Optional[Any] = ...,
    ): ...
    def minimum_reduction(
        self,
        iteration_limit: Optional[Any] = ...,
        multiplier_significant_change_test: Optional[Any] = ...,
        min_n_no_significant_change: Optional[Any] = ...,
    ): ...
    def niggli_cell(
        self,
        relative_epsilon: Optional[Any] = ...,
        iteration_limit: Optional[Any] = ...,
    ): ...
    def niggli_reduction(
        self,
        relative_epsilon: Optional[Any] = ...,
        iteration_limit: Optional[Any] = ...,
    ): ...
    def show_parameters(self, f: Optional[Any] = ..., prefix: str = ...) -> None: ...
    def angle(self, *args, **kwargs) -> Any: ...
    def bases_mean_square_difference(self, *args, **kwargs) -> Any: ...
    def change_basis(self, scitbx) -> Any: ...
    def change_of_basis_op_for_best_monoclinic_beta(self) -> Any: ...
    def compare_monoclinic(self, *args, **kwargs) -> Any: ...
    def compare_orthorhombic(self, *args, **kwargs) -> Any: ...
    def d(self, *args, **kwargs) -> Any: ...
    def d_frac(self, scitbx) -> Any: ...
    def d_metrical_matrix_d_params(self) -> Any: ...
    def d_star_sq(self, *args, **kwargs) -> Any: ...
    def d_volume_d_params(self) -> Any: ...
    def dihedral(self, *args, **kwargs) -> Any: ...
    def distance(self, *args, **kwargs) -> Any: ...
    def fractionalization_matrix(self, *args, **kwargs) -> Any: ...
    def fractionalize(self, scitbx) -> Any: ...
    def fractionalize_gradient(self, scitbx) -> Any: ...
    def grid_index_as_site_cart_matrix(self, scitbx) -> Any: ...
    def is_degenerate(self) -> Any: ...
    def is_similar_to(self, *args, **kwargs) -> Any: ...
    def length(self, *args, **kwargs) -> Any: ...
    def longest_vector_sq(self) -> Any: ...
    def matrix_cart(self, *args, **kwargs) -> Any: ...
    def max_d_star_sq(self, *args, **kwargs) -> Any: ...
    def max_miller_indices(self, *args, **kwargs) -> Any: ...
    def metrical_matrix(self, *args, **kwargs) -> Any: ...
    def min_max_d_star_sq(self, *args, **kwargs) -> Any: ...
    def min_mod_short_distance(self, *args, **kwargs) -> Any: ...
    def mod_short_distance(self, *args, **kwargs) -> Any: ...
    def mod_short_length(self, *args, **kwargs) -> Any: ...
    def orthogonalization_matrix(self, *args, **kwargs) -> Any: ...
    def orthogonalize(self, scitbx) -> Any: ...
    def parameters(self) -> Any: ...
    def reciprocal(self) -> Any: ...
    def reciprocal_metrical_matrix(self) -> Any: ...
    def reciprocal_parameters(self) -> Any: ...
    def reciprocal_space_vector(self, *args, **kwargs) -> Any: ...
    def shortest_vector_sq(self) -> Any: ...
    def similarity_transformations(self, *args, **kwargs) -> Any: ...
    def sin_sq_two_theta(self, *args, **kwargs) -> Any: ...
    def sin_two_theta(self, *args, **kwargs) -> Any: ...
    def stol(self, *args, **kwargs) -> Any: ...
    def stol_sq(self, *args, **kwargs) -> Any: ...
    def two_stol(self, *args, **kwargs) -> Any: ...
    def two_theta(self, *args, **kwargs) -> Any: ...
    def u_star_to_u_cart_linear_map(self) -> Any: ...
    def u_star_to_u_cif_linear_map(self) -> Any: ...
    def u_star_to_u_iso_linear_form(self) -> Any: ...
    def volume(self) -> Any: ...
    def __getinitargs__(self) -> Any: ...
    def __reduce__(self) -> Any: ...

def non_crystallographic_buffer_layer(
    sites_cart_min, sites_cart_max, default_buffer_layer: float = ...
): ...
def non_crystallographic_unit_cell(
    sites_cart: Optional[Any] = ...,
    sites_cart_min: Optional[Any] = ...,
    sites_cart_max: Optional[Any] = ...,
    buffer_layer: Optional[Any] = ...,
    default_buffer_layer: float = ...,
    min_unit_cell_length: int = ...,
): ...

class non_crystallographic_unit_cell_with_the_sites_in_its_center:
    unit_cell: Any
    shift_vector: Any
    sites_cart: Any
    def __init__(
        self,
        sites_cart,
        buffer_layer: Optional[Any] = ...,
        default_buffer_layer: float = ...,
        min_unit_cell_length: int = ...,
    ) -> None: ...
    def crystal_symmetry(self): ...
    def sites_frac(self): ...

def infer_unit_cell_from_symmetry(params, space_group): ...

class distance_mod_1:
    def __init__(self, *args, **kwargs) -> None: ...
    def unit_shifts(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    @property
    def diff_mod(self) -> Any: ...
    @property
    def diff_raw(self) -> Any: ...
    @property
    def dist_sq(self) -> Any: ...

class fast_minimum_reduction:
    def __init__(self, *args, **kwargs) -> None: ...
    def as_gruber_matrix(self, *args, **kwargs) -> Any: ...
    def as_niggli_matrix(self, *args, **kwargs) -> Any: ...
    def as_sym_mat3(self, *args, **kwargs) -> Any: ...
    def as_unit_cell(self, *args, **kwargs) -> Any: ...
    def iteration_limit(self, *args, **kwargs) -> Any: ...
    def min_n_no_significant_change(self, *args, **kwargs) -> Any: ...
    def multiplier_significant_change_test(self, *args, **kwargs) -> Any: ...
    def n_iterations(self, *args, **kwargs) -> Any: ...
    def r_inv(self, *args, **kwargs) -> Any: ...
    def termination_due_to_significant_change_test(self, *args, **kwargs) -> Any: ...
    def type(self, *args, **kwargs) -> Any: ...
    def __reduce__(self) -> Any: ...

def d_as_d_star_sq(double) -> Any: ...
def d_star_sq_as_d(double) -> Any: ...
def d_star_sq_as_stol(double) -> Any: ...
def d_star_sq_as_stol_sq(double) -> Any: ...
def d_star_sq_as_two_stol(double) -> Any: ...
def d_star_sq_as_two_theta(*args, **kwargs) -> Any: ...
def fractional_unit_shifts(cctbx) -> Any: ...
def stol_as_d_star_sq(double) -> Any: ...
def stol_sq_as_d_star_sq(double) -> Any: ...
def two_stol_as_d_star_sq(double) -> Any: ...
def two_theta_as_d(*args, **kwargs) -> Any: ...
def two_theta_as_d_star_sq(*args, **kwargs) -> Any: ...
def unit_cell_angles_are_feasible(scitbx) -> Any: ...
