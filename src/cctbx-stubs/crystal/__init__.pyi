from typing import Any, Optional, Union

import libtbx
from cctbx.sgtbx import (
    change_of_basis_op,
    space_group,
    space_group_info,
    stl_vector_rt_mx,
)
from cctbx.uctbx import unit_cell

class symmetry:
    def __init__(
        self,
        unit_cell: Optional[unit_cell] = ...,
        space_group_symbol: Optional[str] = ...,
        space_group_info: Optional[space_group_info] = ...,
        space_group: Optional[space_group] = ...,
        correct_rhombohedral_setting_if_necessary: bool = ...,
        assert_is_compatible_unit_cell: bool = ...,
        raise_sorry_if_incompatible_unit_cell: bool = ...,
        force_compatible_unit_cell: bool = ...,
    ) -> None: ...
    def change_of_basis_op_to_minimum_cell(self) -> change_of_basis_op: ...
    def change_of_basis_op_to_primitive_setting(self) -> change_of_basis_op: ...
    def is_compatible_unit_cell(self) -> bool: ...
    def space_group(self) -> space_group: ...
    def space_group_info(self) -> space_group_info: ...
    def unit_cell(self) -> Union[unit_cell, unit_cell]: ...
    # Stubgen parts
    def customized_copy(
        self,
        unit_cell=...,
        space_group_info=...,
        raise_sorry_if_incompatible_unit_cell: bool = ...,
    ): ...
    def space_group_number(self): ...
    def as_py_code(self, indent: str = ...): ...
    def show_summary(self, f: Optional[Any] = ..., prefix: str = ...) -> None: ...
    def as_str(self, prefix: str = ...): ...
    def is_identical_symmetry(self, other): ...
    def is_similar_symmetry(
        self,
        other,
        relative_length_tolerance: float = ...,
        absolute_angle_tolerance: float = ...,
        absolute_length_tolerance=...,
    ): ...
    def cell_equivalent_p1(self): ...
    def change_basis(self, cb_op): ...
    def primitive_setting(self): ...
    def change_of_basis_op_to_reference_setting(self): ...
    def as_reference_setting(self): ...
    def change_of_basis_op_to_best_cell(
        self, angular_tolerance: Optional[Any] = ..., best_monoclinic_beta: bool = ...
    ): ...
    def best_cell(self, angular_tolerance: Optional[Any] = ...): ...
    def minimum_cell(self): ...
    def change_of_basis_op_to_niggli_cell(
        self,
        relative_epsilon: Optional[Any] = ...,
        iteration_limit: Optional[Any] = ...,
    ): ...
    def niggli_cell(
        self,
        relative_epsilon: Optional[Any] = ...,
        iteration_limit: Optional[Any] = ...,
    ): ...
    def change_of_basis_op_to_inverse_hand(self): ...
    def inverse_hand(self): ...
    def reflection_intensity_symmetry(self, anomalous_flag): ...
    def patterson_symmetry(self): ...
    def is_patterson_symmetry(self): ...
    def join_symmetry(
        self,
        other_symmetry,
        force: bool = ...,
        raise_sorry_if_incompatible_unit_cell: bool = ...,
    ): ...
    def subtract_continuous_allowed_origin_shifts(self, translation_cart): ...
    def direct_space_asu(self): ...
    def gridding(
        self,
        d_min: Optional[Any] = ...,
        resolution_factor: Optional[Any] = ...,
        step: Optional[Any] = ...,
        symmetry_flags: Optional[Any] = ...,
        mandatory_factors: Optional[Any] = ...,
        max_prime: int = ...,
        assert_shannon_sampling: bool = ...,
    ): ...
    # Note: This is NOT positional-only in the original code, however,
    # the special_position_settings subclass has an incompatible declaration.
    # A short survey revealed no obvious direct uses of this positionally.
    def asu_mappings(
        self, *, buffer_thickness, asu_is_inside_epsilon: Optional[Any] = ...
    ): ...
    def average_u_cart(self, u_cart): ...
    def average_b_cart(self, b_cart): ...
    def special_position_settings(
        self,
        min_distance_sym_equiv: float = ...,
        u_star_tolerance: int = ...,
        assert_min_distance_sym_equiv: bool = ...,
    ): ...
    def miller_set(self, indices, anomalous_flag): ...
    def build_miller_set(self, anomalous_flag, d_min, d_max: Optional[Any] = ...): ...
    def as_pdb_remark_290(self): ...
    def as_cif_block(
        self,
        cell_covariance_matrix: Optional[Any] = ...,
        format: str = ...,
        numeric_format: str = ...,
    ): ...
    def expand_to_p1(self, sites_cart): ...
    def is_nonsense(self): ...
    def is_empty(self): ...

def select_crystal_symmetry(
    from_command_line: Optional[Any] = ...,
    from_parameter_file: Optional[Any] = ...,
    from_coordinate_files=...,
    from_reflection_files=...,
    enforce_similarity: bool = ...,
    absolute_angle_tolerance: float = ...,
    absolute_length_tolerance=...,
): ...
def non_crystallographic_symmetry(
    sites_cart: Optional[Any] = ...,
    sites_cart_min: Optional[Any] = ...,
    sites_cart_max: Optional[Any] = ...,
    buffer_layer: Optional[Any] = ...,
    default_buffer_layer: float = ...,
    min_unit_cell_length: int = ...,
): ...

class special_position_settings(symmetry):
    def __init__(
        self,
        crystal_symmetry,
        min_distance_sym_equiv: float = ...,
        u_star_tolerance: int = ...,
        assert_min_distance_sym_equiv: bool = ...,
    ) -> None: ...
    def min_distance_sym_equiv(self): ...
    def u_star_tolerance(self): ...
    def assert_min_distance_sym_equiv(self): ...
    def change_basis(self, cb_op): ...
    def site_symmetry(
        self, site: Optional[Any] = ..., site_cart: Optional[Any] = ...
    ): ...
    def sym_equiv_sites(self, site): ...
    def site_symmetry_table(
        self,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        unconditional_general_position_flags: Optional[Any] = ...,
    ): ...
    def xray_structure(self, scatterers: Optional[Any] = ...): ...
    def asu_mappings(
        self,
        *,
        buffer_thickness,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        site_symmetry_table: Optional[Any] = ...,
        asu_is_inside_epsilon: Optional[Any] = ...
    ): ...
    def pair_generator(
        self,
        distance_cutoff,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        site_symmetry_table: Optional[Any] = ...,
        asu_mappings_buffer_thickness: Optional[Any] = ...,
        asu_is_inside_epsilon: Optional[Any] = ...,
        minimal: bool = ...,
    ): ...
    def pair_asu_table(
        self,
        distance_cutoff,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        site_symmetry_table: Optional[Any] = ...,
        asu_mappings_buffer_thickness: Optional[Any] = ...,
        asu_is_inside_epsilon: Optional[Any] = ...,
        min_cubicle_edge: int = ...,
        distance_cutoff_epsilon: Optional[Any] = ...,
    ): ...
    def incremental_pairs(
        self,
        distance_cutoff,
        asu_is_inside_epsilon: Optional[Any] = ...,
        asu_mappings_buffer_thickness: int = ...,
        cubicle_epsilon: int = ...,
    ): ...
    def site_cluster_analysis(
        self,
        min_distance: Optional[Any] = ...,
        min_cross_distance: Optional[Any] = ...,
        min_self_distance: Optional[Any] = ...,
        general_positions_only: bool = ...,
        estimated_reduction_factor: int = ...,
        asu_is_inside_epsilon: Optional[Any] = ...,
        asu_mappings_buffer_thickness: int = ...,
        min_cubicle_edge: int = ...,
        cubicle_epsilon: int = ...,
    ): ...

def correct_special_position(
    crystal_symmetry,
    special_op,
    site_frac: Optional[Any] = ...,
    site_cart: Optional[Any] = ...,
    site_label: Optional[Any] = ...,
    tolerance: int = ...,
    error_message: str = ...,
): ...

class calculate_distances:
    distances: Any
    variances: Any
    pair_counts: Any
    def __init__(
        self,
        pair_asu_table,
        sites_frac,
        skip_j_seq_less_than_i_seq: bool = ...,
        covariance_matrix: Optional[Any] = ...,
        cell_covariance_matrix: Optional[Any] = ...,
        parameter_map: Optional[Any] = ...,
    ) -> None: ...
    def __iter__(self): ...
    def __next__(self) -> None: ...

class show_distances(libtbx.slots_getstate_setstate):
    pair_asu_table: Any
    distances_info: Any
    have_sym: bool
    def __init__(
        self,
        pair_asu_table,
        site_labels: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        show_cartesian: bool = ...,
        keep_pair_asu_table: bool = ...,
        skip_j_seq_less_than_i_seq: bool = ...,
        out: Optional[Any] = ...,
    ) -> None: ...

class calculate_angles:
    distances: Any
    variances: Any
    angles: Any
    pair_counts: Any
    def __init__(
        self,
        pair_asu_table,
        sites_frac,
        skip_j_seq_less_than_i_seq: bool = ...,
        covariance_matrix: Optional[Any] = ...,
        cell_covariance_matrix: Optional[Any] = ...,
        parameter_map: Optional[Any] = ...,
        conformer_indices: Optional[Any] = ...,
    ) -> None: ...
    def __iter__(self): ...
    def __next__(self) -> None: ...

class show_angles:
    pair_asu_table: Any
    angles: Any
    distance: Any
    def __init__(
        self,
        pair_asu_table,
        site_labels: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        show_cartesian: bool = ...,
        keep_pair_asu_table: bool = ...,
        out: Optional[Any] = ...,
    ) -> None: ...

class dihedral_angle_def:
    def __init__(self, seqs, rt_mxs) -> None: ...

class calculate_dihedrals:
    variances: Any
    dihedrals: Any
    def __init__(
        self,
        pair_asu_table,
        sites_frac,
        dihedral_defs: Optional[Any] = ...,
        skip_j_seq_less_than_i_seq: bool = ...,
        covariance_matrix: Optional[Any] = ...,
        cell_covariance_matrix: Optional[Any] = ...,
        parameter_map: Optional[Any] = ...,
        conformer_indices: Optional[Any] = ...,
        max_d: float = ...,
        max_angle: int = ...,
    ) -> None: ...
    def __iter__(self): ...
    def next(self): ...

class show_dihedral_angles:
    dihedrals: Any
    def __init__(
        self,
        pair_asu_table,
        site_labels: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        show_cartesian: bool = ...,
        max_d: float = ...,
        max_angle: int = ...,
        out: Optional[Any] = ...,
    ) -> None: ...

class sym_pair(libtbx.slots_getstate_setstate):
    i_seq: Any
    j_seq: Any
    rt_mx_ji: Any
    def __init__(self, i_seq, j_seq, rt_mx_ji) -> None: ...
    def i_seqs(self): ...

class _clustering_mix_in:
    def sites_cart(self): ...
    index_groups: Any
    def tidy_index_groups_in_place(self): ...

class incremental_clustering(_clustering_mix_in):
    special_position_settings: Any
    distance_cutoffs: Any
    sites_frac: Any
    index_groups: Any
    def __init__(
        self,
        special_position_settings,
        sites_cart,
        distance_cutoffs,
        scores: Optional[Any] = ...,
        discard_special_positions: bool = ...,
        discard_not_strictly_inside_asu: bool = ...,
        initial_required_cluster_size: int = ...,
    ) -> None: ...

class distance_based_clustering(_clustering_mix_in):
    special_position_settings: Any
    distance_cutoff: Any
    sites_frac: Any
    index_groups: Any
    def __init__(
        self,
        special_position_settings,
        sites_cart,
        distance_cutoff,
        discard_special_positions: bool = ...,
    ) -> None: ...

def cluster_erosion(sites_cart, box_size, fraction_to_be_retained): ...
def unit_crystal_symmetry(): ...

from typing import Any, ClassVar

class adp_iso_local_sphere_restraints_energies:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def gradients(self) -> Any: ...
    @property
    def number_of_restraints(self) -> Any: ...
    @property
    def r_ij(self) -> Any: ...
    @property
    def residual_sum(self) -> Any: ...
    @property
    def u_i(self) -> Any: ...
    @property
    def u_j(self) -> Any: ...

class asu_clusters:
    def __init__(self, *args, **kwargs) -> None: ...
    def sort_index_groups_by_size(self) -> Any: ...
    def sort_indices_in_each_group(self) -> Any: ...
    @property
    def index_groups(self) -> Any: ...

class close_packing_hexagonal_sampling_generator:
    def __init__(self, *args, **kwargs) -> None: ...
    def all_sites_frac(self) -> Any: ...
    def all_twelve_neighbors(self) -> Any: ...
    def at_end(self) -> Any: ...
    def box_lower(self) -> Any: ...
    def box_upper(self) -> Any: ...
    def buffer_thickness(self) -> Any: ...
    def cb_op_original_to_sampling(self) -> Any: ...
    def continuous_shift_flags(self) -> Any: ...
    def count_sites(self) -> Any: ...
    def float_asu(self) -> Any: ...
    def next(self) -> Any: ...
    def next_site_frac(self) -> Any: ...
    def point_distance(self) -> Any: ...
    def restart(self) -> Any: ...
    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...

class direct_space_asu_array_of_array_of_mappings_for_one_site:
    def __init__(self, unsignedlong) -> None: ...
    def append(self, *args, **kwargs) -> Any: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def deep_copy(self, *args, **kwargs) -> Any: ...
    def extend(self, *args, **kwargs) -> Any: ...
    def insert(self, *args, **kwargs) -> Any: ...
    def reserve(self, *args, **kwargs) -> Any: ...
    def size(self, *args, **kwargs) -> Any: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __len__(self) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...

class direct_space_asu_asu_mapping:
    def __init__(self, *args, **kwargs) -> None: ...
    def i_sym_op(self, *args, **kwargs) -> Any: ...
    def mapped_site(self, *args, **kwargs) -> Any: ...
    def unit_shifts(self, *args, **kwargs) -> Any: ...

class direct_space_asu_asu_mapping_index_pair:
    def __init__(self, *args, **kwargs) -> None: ...
    def is_active(self) -> Any: ...
    @property
    def i_seq(self) -> Any: ...
    @property
    def j_seq(self) -> Any: ...
    @property
    def j_sym(self) -> Any: ...

class direct_space_asu_asu_mapping_index_pair_and_diff(
    direct_space_asu_asu_mapping_index_pair
):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def diff_vec(self) -> Any: ...
    @property
    def dist_sq(self) -> Any: ...

class direct_space_asu_asu_mappings:
    def __init__(self, *args, **kwargs) -> None: ...
    def asu(self, *args, **kwargs) -> Any: ...
    def asu_buffer(self, *args, **kwargs) -> Any: ...
    def buffer_covering_sphere(self, *args, **kwargs) -> Any: ...
    def buffer_thickness(self, *args, **kwargs) -> Any: ...
    def diff_vec(self, *args, **kwargs) -> Any: ...
    def find_i_sym(self, *args, **kwargs) -> Any: ...
    def get_rt_mx(self, *args, **kwargs) -> Any: ...
    def get_rt_mx_i(self, *args, **kwargs) -> Any: ...
    def get_rt_mx_j(self, *args, **kwargs) -> Any: ...
    def is_simple_interaction(self, *args, **kwargs) -> Any: ...
    def make_pair(self, *args, **kwargs) -> Any: ...
    def make_trial_pair(self, *args, **kwargs) -> Any: ...
    def map_moved_site_to_asu(self, *args, **kwargs) -> Any: ...
    def mapped_sites_max(self, *args, **kwargs) -> Any: ...
    def mapped_sites_min(self, *args, **kwargs) -> Any: ...
    def mapped_sites_span(self, *args, **kwargs) -> Any: ...
    def mappings(self, *args, **kwargs) -> Any: ...
    def n_sites_in_asu_and_buffer(self, *args, **kwargs) -> Any: ...
    def process(self, *args, **kwargs) -> Any: ...
    def process_sites_cart(self, *args, **kwargs) -> Any: ...
    def process_sites_frac(self, *args, **kwargs) -> Any: ...
    def r_inv_cart(self, *args, **kwargs) -> Any: ...
    def reserve(self, *args, **kwargs) -> Any: ...
    def site_symmetry_table(self, *args, **kwargs) -> Any: ...
    def space_group(self, *args, **kwargs) -> Any: ...
    def special_op(self, *args, **kwargs) -> Any: ...
    def unit_cell(self, *args, **kwargs) -> Any: ...

class direct_space_asu_float_asu:
    def __init__(self, *args, **kwargs) -> None: ...
    def _add_buffer(self, double) -> Any: ...
    def box_max(self) -> Any: ...
    def box_min(self) -> Any: ...
    def cuts(self) -> Any: ...
    def is_inside(self, *args, **kwargs) -> Any: ...
    def is_inside_cart(self, *args, **kwargs) -> Any: ...
    def is_inside_epsilon(self) -> Any: ...
    def is_inside_frac(self, *args, **kwargs) -> Any: ...
    def shape_vertices(self) -> Any: ...
    def unit_cell(self, *args, **kwargs) -> Any: ...

class direct_space_asu_float_cut_plane:

    c: Any
    n: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def add_buffer(self, *args, **kwargs) -> Any: ...
    def evaluate(self, *args, **kwargs) -> Any: ...
    def get_point_in_plane(self) -> Any: ...
    def is_inside(self, *args, **kwargs) -> Any: ...

class incremental_pairs:

    assert_min_distance_sym_equiv: Any
    min_distance_sym_equiv: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def asu_mappings(self, *args, **kwargs) -> Any: ...
    def cubicle_size_counts(self, *args, **kwargs) -> Any: ...
    def pair_asu_table(self, *args, **kwargs) -> Any: ...
    def process_site_frac(self, *args, **kwargs) -> Any: ...
    def process_sites_cart(self, *args, **kwargs) -> Any: ...
    def process_sites_frac(self, *args, **kwargs) -> Any: ...

class neighbors_fast_pair_generator(neighbors_simple_pair_generator):
    def __init__(self, *args, **kwargs) -> None: ...
    def count_pairs(self, *args, **kwargs) -> Any: ...
    def distance_based_simple_two_way_bond_sets(self, *args, **kwargs) -> Any: ...
    def epsilon(self, *args, **kwargs) -> Any: ...
    def max_distance_sq(self, *args, **kwargs) -> Any: ...
    def n_boxes(self, *args, **kwargs) -> Any: ...
    def neighbors_of(self, *args, **kwargs) -> Any: ...
    def next(self, *args, **kwargs) -> Any: ...
    def restart(self, *args, **kwargs) -> Any: ...

class neighbors_simple_pair_generator:
    def __init__(self, *args, **kwargs) -> None: ...
    def asu_mappings(self, *args, **kwargs) -> Any: ...
    def at_end(self, *args, **kwargs) -> Any: ...
    def count_pairs(self, *args, **kwargs) -> Any: ...
    def distance_cutoff_sq(self, *args, **kwargs) -> Any: ...
    def is_simple_interaction(self, *args, **kwargs) -> Any: ...
    def max_distance_sq(self, *args, **kwargs) -> Any: ...
    def minimal(self, *args, **kwargs) -> Any: ...
    def neighbors_of(self, *args, **kwargs) -> Any: ...
    def next(self, *args, **kwargs) -> Any: ...
    def restart(self, *args, **kwargs) -> Any: ...
    def __iter__(self) -> Any: ...

class pair_asu_dict:
    def __init__(self, *args, **kwargs) -> None: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def erase(self, *args, **kwargs) -> Any: ...
    def get(self, *args, **kwargs) -> Any: ...
    def has_key(self, *args, **kwargs) -> Any: ...
    def items(self) -> Any: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def popitem(self, *args, **kwargs) -> Any: ...
    def setdefault(self, *args, **kwargs) -> Any: ...
    def size(self, *args, **kwargs) -> Any: ...
    def update(self, *args, **kwargs) -> Any: ...
    def values(self) -> Any: ...
    def __contains__(self, other) -> Any: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...

class pair_asu_table:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_all_pairs(self, *args, **kwargs) -> Any: ...
    def add_covalent_pairs(self, *args, **kwargs) -> Any: ...
    def add_pair(self, *args, **kwargs) -> Any: ...
    def add_pair_sym_table(self, *args, **kwargs) -> Any: ...
    def angle_pair_asu_table(self, *args, **kwargs) -> Any: ...
    def asu_mappings(self, *args, **kwargs) -> Any: ...
    def cluster_pivot_selection(self, *args, **kwargs) -> Any: ...
    def contains(self, *args, **kwargs) -> Any: ...
    def extract_pair_sym_table(self, *args, **kwargs) -> Any: ...
    def pair_counts(self, *args, **kwargs) -> Any: ...
    def table(self, *args, **kwargs) -> Any: ...
    def __contains__(self, other) -> Any: ...
    def __eq__(self, other) -> Any: ...
    def __ne__(self, other) -> Any: ...
    # Injected
    def as_nested_lists(self): ...
    def show(
        self, f: Optional[Any] = ..., site_labels: Optional[Any] = ...
    ) -> None: ...
    def show_distances(
        self,
        site_labels: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        show_cartesian: bool = ...,
        keep_pair_asu_table: bool = ...,
        out: Optional[Any] = ...,
    ): ...
    def show_angles(
        self,
        site_labels: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        keep_pair_asu_table: bool = ...,
        out: Optional[Any] = ...,
    ): ...
    def show_dihedral_angles(
        self,
        site_labels: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        keep_pair_asu_table: bool = ...,
        max_d: float = ...,
        max_angle: int = ...,
        out: Optional[Any] = ...,
    ): ...

class pair_asu_table_table:
    def __init__(self, unsignedlong) -> None: ...
    def append(self, *args, **kwargs) -> Any: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def deep_copy(self, *args, **kwargs) -> Any: ...
    def extend(self, *args, **kwargs) -> Any: ...
    def insert(self, *args, **kwargs) -> Any: ...
    def reserve(self, *args, **kwargs) -> Any: ...
    def size(self, *args, **kwargs) -> Any: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __len__(self) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...

class pair_sym_dict:
    def __init__(self, *args, **kwargs) -> None: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def erase(self, *args, **kwargs) -> Any: ...
    def get(self, *args, **kwargs) -> Any: ...
    def has_key(self, *args, **kwargs) -> Any: ...
    def items(self) -> Any: ...
    def keys(self, *args, **kwargs) -> Any: ...
    def popitem(self, *args, **kwargs) -> Any: ...
    def setdefault(self, *args, **kwargs) -> Any: ...
    def size(self, *args, **kwargs) -> Any: ...
    def update(self, *args, **kwargs) -> Any: ...
    def values(self) -> Any: ...
    def __contains__(self, other) -> Any: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __iter__(self) -> Any: ...
    def __len__(self) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...

class pair_sym_table:
    def __init__(self, unsignedlong) -> None: ...
    def append(self, *args, **kwargs) -> Any: ...
    def clear(self, *args, **kwargs) -> Any: ...
    def deep_copy(self, *args, **kwargs) -> Any: ...
    def extend(self, *args, **kwargs) -> Any: ...
    def insert(self, *args, **kwargs) -> Any: ...
    def proxy_select(self, *args, **kwargs) -> Any: ...
    def reserve(self, *args, **kwargs) -> Any: ...
    def size(self, *args, **kwargs) -> Any: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __len__(self) -> Any: ...
    def __setitem__(self, index, object) -> Any: ...
    # Injected
    def iterator(self) -> None: ...
    def tidy(self, site_symmetry_table): ...
    def full_connectivity(self, site_symmetry_table: Optional[Any] = ...): ...
    def show(
        self,
        f: Optional[Any] = ...,
        site_labels: Optional[Any] = ...,
        site_symmetry_table: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        unit_cell: Optional[Any] = ...,
    ) -> None: ...
    def show_distances(
        self,
        unit_cell,
        site_symmetry_table,
        site_labels: Optional[Any] = ...,
        sites_frac: Optional[Any] = ...,
        sites_cart: Optional[Any] = ...,
        show_cartesian: bool = ...,
        skip_j_seq_less_than_i_seq: bool = ...,
        skip_sym_equiv: bool = ...,
        out: Optional[Any] = ...,
    ): ...
    def number_of_pairs_involving_symmetry(self): ...
    def simple_edge_list(self): ...
    def symmetry_edge_list(self): ...
    def both_edge_list(self): ...
    def full_simple_connectivity(self): ...
    def is_paired(self, i_seq): ...
    def discard_symmetry(self): ...
    def add_pair_sym_table_in_place(self, other) -> None: ...

class site_cluster_analysis:

    assert_min_distance_sym_equiv: Any
    estimated_reduction_factor: Any
    min_distance_sym_equiv: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def asu_mappings(self, *args, **kwargs) -> Any: ...
    def discard_last(self, *args, **kwargs) -> Any: ...
    def insert_fixed_site_frac(self, *args, **kwargs) -> Any: ...
    def process_site_frac(self, *args, **kwargs) -> Any: ...
    def process_sites_cart(self, *args, **kwargs) -> Any: ...
    def process_sites_frac(self, *args, **kwargs) -> Any: ...
    @property
    def general_positions_only(self) -> Any: ...
    @property
    def min_cross_distance(self) -> Any: ...
    @property
    def min_self_distance(self) -> Any: ...

def coordination_sequences_shell_asu_tables(*args, **kwargs) -> Any: ...
def coordination_sequences_shell_sym_tables(*args, **kwargs) -> Any: ...
def coordination_sequences_simple(*args, **kwargs) -> Any: ...
def coordination_sequences_simple_sym(*args, **kwargs) -> Any: ...
def cubicles_max_memory_allocation_get() -> Any: ...
def cubicles_max_memory_allocation_set(unsignedlong) -> Any: ...
def get_distances(*args, **kwargs) -> Any: ...
